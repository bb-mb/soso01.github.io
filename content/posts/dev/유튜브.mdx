---
title: 유튜브
date: 2019-11-12
description: Defence Against the Dark Arts (abbreviated as DADA) is a subject taught at Hogwarts School of Witchcraft and Wizardry and Ilvermorny School of Witchcraft and Wizardry.
tags:
  - dev
banner: ./defence-against-the-dark-arts.jpg
canonicalUrl: https://random-blog-about-curses.com/curses-counter-curses-and-more
---

출처 - [https://jbee.io/react/headless-concept/?fbclid=IwAR2VLwrCFk3rVNXR1dkDSj4QxolM-kgkm1an3gMWa7tbOlXQ_Q3MixERaG0](https://jbee.io/react/headless-concept/?fbclid=IwAR2VLwrCFk3rVNXR1dkDSj4QxolM-kgkm1an3gMWa7tbOlXQ_Q3MixERaG0)

UI 라이브러리들을 둘러보면 '스타일'이 포함되어 바로 사용하기 곤란한 경우가 많다.

대부분의 스타일 재정의는 CSS Override로 쉽게 제어가 가능하지만 몇가지 단점이 존재한다.

- 오버라이드한 클래스가 다른 클래스로 변경되면 스타일이 동작하지 않음
- 오버라이드한 스타일이 내부적으로 오버라이드 할 수 없게 되는 케이스가 발생(우선순위 이슈)
- CSS in JS 방식으로 애플리케이션을 스타일링 하고 있다면 postcss라도 설치해서 css를 별도로 컴파일 해줘야한다.
- 리소스는 한정적인데, 처음부터 만드는 것 보다 손이 많은 작업이다.
- 위와 같은 이슈로 관리가 안된다.

사용하고 있는 라이브러리에 적용된 class를 알아내서 직접 재정의 하는 것은 너무 귀찮고 번거로운 일이다. 그렇다고 라이브러리를 새로 만들기엔 기존 로직을 처음부터 작성하는 고통

# Headless

당연하게도 어떤 상태를 가지고 있는 컴포넌트는 이 상태를 제어하는 부분과 스타일을 제어하는 부분으로 나눌 수 있다.

헤드리스 개념은 스타일링을 담당하는 부분을 과감하게 제외하고 상태와 관련된 부분만을 다루자고 이야기함.

### 스타일 정의에 대한 역할 위임

독자적인 스타일을 가지는 여러 서드파티들이 스타일 재정의 없이 한 제품에 사용되는 순간 제품의 완성도가 떨어지게 된다.(UI, UX 통일성을 해침)

스타일은 라이브러리를 사용하는 개발자에게 위임하고 자신은 상태와 그 상태를 제어할 수 있는 인터페이스만 노출한다. 원하는 디자인 시스템을 가져다 쓰거나 직접 스타일을 구현하는 자유를 주는 것이다.

## 장점

### 1. 관심사의 분리

사용자 인터페이스를 스타일링하는 코드와, 스타일링 된요소가 어떻게 보여질지 결정하는 비즈니스 로직은 별도로 관리되어야 한다. UI에는 수많은 경우가 존재하고 이는 변경에 그만큼 취약하다고 볼 수 있다. 이에 반해 데이터를 다루는 로직은 상대적으로 변경 가능성이 낮다.

예로 달력의 경우 1주일이 7일 이라는 것이 변경될 가능성은 0에 수렴함.

좋지 않은 코드가 생산되는 이유로, (무지성으로) 변경에 대응하다 보면 좋지 않은 코드가 자연스럽게 생산된다. 이러한 이유로 변경 가능성이 높은 코드와 변경 가능성이 낮은 코드를 분리해둬야 한다.

관심사를 분리하는 것이 결국 변경 가능성에 따른 분리가 되었고, 스타일링을 담당하는 코드와 상태를 다루는 코드를 분리하는 것이 좋은 코드의 출발점이 될 수 있다.

### 2. 유지보수 용이성

스타일을 담당하는 코드가 함께 추상화된다면 이 스타일을 재정의하기 위한 여러 인터페이스를 열어둬야 한다. (수많은 Props와 함께) 컴포넌트에게 Props는 외부에 노출되는 인터페이스를 의미하며 이 인터페이스는 가장 중요한 관리의 대상이 된다. 외부로 노출되는 인터페이스 중 하나가 그 역할이 달라지거나 수정되는 순간 바로 Breacking Change를 발생.

라이브러리 또는 저수준 모듈에서의 Breacking Change는 프로덕션 레벨 코드의 변경을 의미한다. 변경은 버그가 발생할 가능성을 높인다.

즉, 변경에 취약한 UI를 고려하여 외부로 공개되는 인터페이스가 많아질수록 추상화 된 코드는 관리가 어려워지기 때문에 각각 관리함으로써 보다 코드를 잘 관리할 수 있게 되는 것이다.

## 어떻게 작성할 수 있을까?

위 이야기는 고차컴포넌트와 크게 다르지 않다. [https://ko.reactjs.org/docs/higher-order-components.html#use-hocs-for-cross-cutting-concerns](https://ko.reactjs.org/docs/higher-order-components.html#use-hocs-for-cross-cutting-concerns)

### 추상화

UI가 가지고 있는 상태를 '추상화'하여 그것을 모듈화하는 것으로 Headless를 구현할 수 있다. 스타일은 걷어내고 이 UI가 내포하고 있는 상태는 무엇이며 이 상태를 관리하기 위한 적절한 자료구조는 무엇인지 고민하는 것이 우선이다. 그리고 그 상태를 제어할 수 있는 최소한의 API만을 제공한다.

달력 추상화 예시

1. 달력의 UI를 Table 엘리먼트로 구성 (HTML 요소로 추상화)
2. Table Body에 렌더링되는 데이터는 보여지는 데이터 2x2 배열이라고 할 수 있다. (데이터 자료구조 추상화)
3. 달력은 '현재 보여지고 있는 월(Month)'라는 값을 상태로 가지고 있다. (상태 추상화)
4. 이 현재 보여지고 있는 월을 제어할 수 있다. (인터페이스 추상화)

즉 헤드리스 캘린더 라이브러리는 달력이 어떻게 스타일링 될 지 관심없고 오직 상태에 대한 것만 관리한다. 인터페이스 구성을 어떻게 하느냐에 따라 다르겠지만 상태와 달력을 그리는 데 필요한 데이터 그리고 상태를 조작할 수 있는 핸들러를 반환하면 된다.

### 마무리

라이브러리를 만드는 경우 말고도 프로덕션 코드에서도 이 개념을 쉽게 적용할 수 있다. 거창하게 헤드리스라는 이름을 붙였지만 관심사의 분리일 뿐이다. 상태를 다루는 부분과 스타일을 담당하는 코드를 나눠서 고나리하여 확장 가능하고 재사용 가능한 hooks와 컴포넌트를 만들 수 있는 것이다.

### **대표적인 라이브러리**

- [veccu/react-calendar](https://github.com/veccu/react-calendar)
- [tannerlinsley/react-table](https://github.com/tannerlinsley/react-table)
- [jxom/awesome-react-headless-components](https://github.com/jxom/awesome-react-headless-components)

컨테이너 컴포넌트 / 프레젠테이션 컴포넌트로 분리하는 것이랑 같은 얘기인 것 같다.

그런데 프레젠테이션 컴포넌트에서 props를 줄일 수 있는지 모르겠음.
